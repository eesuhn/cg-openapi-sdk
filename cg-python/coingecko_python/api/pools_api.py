# coding: utf-8

"""
    CoinGecko API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v3.1.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from coingecko_python.models.pool import Pool
from coingecko_python.models.pool_info import PoolInfo

from coingecko_python.api_client import ApiClient, RequestSerialized
from coingecko_python.api_response import ApiResponse
from coingecko_python.rest import RESTResponseType


class PoolsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def latest_pools_list(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """New Pools List

        This endpoint allows you to **query all the latest pools across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._latest_pools_list_serialize(
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def latest_pools_list_with_http_info(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """New Pools List

        This endpoint allows you to **query all the latest pools across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._latest_pools_list_serialize(
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def latest_pools_list_without_preload_content(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New Pools List

        This endpoint allows you to **query all the latest pools across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._latest_pools_list_serialize(
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _latest_pools_list_serialize(
        self,
        include,
        page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/new_pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def latest_pools_network(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """New Pools by Network

        This endpoint allows you to **query all the latest pools based on provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._latest_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def latest_pools_network_with_http_info(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """New Pools by Network

        This endpoint allows you to **query all the latest pools based on provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._latest_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def latest_pools_network_without_preload_content(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New Pools by Network

        This endpoint allows you to **query all the latest pools based on provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._latest_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _latest_pools_network_serialize(
        self,
        network,
        include,
        page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/{network}/new_pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pool_address(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        address: Annotated[StrictStr, Field(description="pool address")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PoolInfo:
        """Specific Pool Data by Pool Address

        This endpoint allows you to **query the specific pool based on the provided network and pool address**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param address: pool address (required)
        :type address: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pool_address_serialize(
            network=network,
            address=address,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PoolInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pool_address_with_http_info(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        address: Annotated[StrictStr, Field(description="pool address")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PoolInfo]:
        """Specific Pool Data by Pool Address

        This endpoint allows you to **query the specific pool based on the provided network and pool address**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param address: pool address (required)
        :type address: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pool_address_serialize(
            network=network,
            address=address,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PoolInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pool_address_without_preload_content(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        address: Annotated[StrictStr, Field(description="pool address")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Specific Pool Data by Pool Address

        This endpoint allows you to **query the specific pool based on the provided network and pool address**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param address: pool address (required)
        :type address: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pool_address_serialize(
            network=network,
            address=address,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PoolInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pool_address_serialize(
        self,
        network,
        address,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network is not None:
            _path_params['network'] = network
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/{network}/pools/{address}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pools_addresses(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        addresses: Annotated[StrictStr, Field(description="pool contract address, comma-separated if more than one pool contract address")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PoolInfo:
        """Multiple Pools Data by Pool Addresses

        This endpoint allows you to **query multiple pools based on the provided network and pool address**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param addresses: pool contract address, comma-separated if more than one pool contract address (required)
        :type addresses: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pools_addresses_serialize(
            network=network,
            addresses=addresses,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PoolInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pools_addresses_with_http_info(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        addresses: Annotated[StrictStr, Field(description="pool contract address, comma-separated if more than one pool contract address")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PoolInfo]:
        """Multiple Pools Data by Pool Addresses

        This endpoint allows you to **query multiple pools based on the provided network and pool address**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param addresses: pool contract address, comma-separated if more than one pool contract address (required)
        :type addresses: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pools_addresses_serialize(
            network=network,
            addresses=addresses,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PoolInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pools_addresses_without_preload_content(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        addresses: Annotated[StrictStr, Field(description="pool contract address, comma-separated if more than one pool contract address")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Multiple Pools Data by Pool Addresses

        This endpoint allows you to **query multiple pools based on the provided network and pool address**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param addresses: pool contract address, comma-separated if more than one pool contract address (required)
        :type addresses: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pools_addresses_serialize(
            network=network,
            addresses=addresses,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PoolInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pools_addresses_serialize(
        self,
        network,
        addresses,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network is not None:
            _path_params['network'] = network
        if addresses is not None:
            _path_params['addresses'] = addresses
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/{network}/pools/multi/{addresses}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pools_megafilter(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        networks: Annotated[Optional[StrictStr], Field(description="filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)")] = None,
        dexes: Annotated[Optional[StrictStr], Field(description="filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h6_trending")] = None,
        fdv_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum fully diluted value in USD")] = None,
        fdv_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum fully diluted value in USD")] = None,
        reserve_in_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum reserve in USD")] = None,
        reserve_in_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum reserve in USD")] = None,
        h24_volume_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum 24hr volume in USD")] = None,
        h24_volume_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum 24hr volume in USD")] = None,
        pool_created_hour_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum pool age in hours")] = None,
        pool_created_hour_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum pool age in hours")] = None,
        tx_count_min: Annotated[Optional[StrictInt], Field(description="minimum transaction count")] = None,
        tx_count_max: Annotated[Optional[StrictInt], Field(description="maximum transaction count")] = None,
        tx_count_duration: Annotated[Optional[StrictStr], Field(description="duration for transaction count metric <br> Default value: 24h")] = None,
        buys_min: Annotated[Optional[StrictInt], Field(description="minimum number of buy transactions")] = None,
        buys_max: Annotated[Optional[StrictInt], Field(description="maximum number of buy transactions")] = None,
        buys_duration: Annotated[Optional[StrictStr], Field(description="duration for buy transactions metric <br> Default value: 24h")] = None,
        sells_min: Annotated[Optional[StrictInt], Field(description="minimum number of sell transactions")] = None,
        sells_max: Annotated[Optional[StrictInt], Field(description="maximum number of sell transactions")] = None,
        sells_duration: Annotated[Optional[StrictStr], Field(description="duration for sell transactions metric <br> Default value: 24h")] = None,
        checks: Annotated[Optional[StrictStr], Field(description="filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`")] = None,
        buy_tax_percentage_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum buy tax percentage")] = None,
        buy_tax_percentage_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum buy tax percentage")] = None,
        sell_tax_percentage_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum sell tax percentage")] = None,
        sell_tax_percentage_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum sell tax percentage")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """ Megafilter for Pools

        This endpoint allows you to **query pools based on various filters across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param networks: filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)
        :type networks: str
        :param dexes: filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)
        :type dexes: str
        :param sort: sort the pools by field <br> Default value: h6_trending
        :type sort: str
        :param fdv_usd_min: minimum fully diluted value in USD
        :type fdv_usd_min: float
        :param fdv_usd_max: maximum fully diluted value in USD
        :type fdv_usd_max: float
        :param reserve_in_usd_min: minimum reserve in USD
        :type reserve_in_usd_min: float
        :param reserve_in_usd_max: maximum reserve in USD
        :type reserve_in_usd_max: float
        :param h24_volume_usd_min: minimum 24hr volume in USD
        :type h24_volume_usd_min: float
        :param h24_volume_usd_max: maximum 24hr volume in USD
        :type h24_volume_usd_max: float
        :param pool_created_hour_min: minimum pool age in hours
        :type pool_created_hour_min: float
        :param pool_created_hour_max: maximum pool age in hours
        :type pool_created_hour_max: float
        :param tx_count_min: minimum transaction count
        :type tx_count_min: int
        :param tx_count_max: maximum transaction count
        :type tx_count_max: int
        :param tx_count_duration: duration for transaction count metric <br> Default value: 24h
        :type tx_count_duration: str
        :param buys_min: minimum number of buy transactions
        :type buys_min: int
        :param buys_max: maximum number of buy transactions
        :type buys_max: int
        :param buys_duration: duration for buy transactions metric <br> Default value: 24h
        :type buys_duration: str
        :param sells_min: minimum number of sell transactions
        :type sells_min: int
        :param sells_max: maximum number of sell transactions
        :type sells_max: int
        :param sells_duration: duration for sell transactions metric <br> Default value: 24h
        :type sells_duration: str
        :param checks: filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`
        :type checks: str
        :param buy_tax_percentage_min: minimum buy tax percentage
        :type buy_tax_percentage_min: float
        :param buy_tax_percentage_max: maximum buy tax percentage
        :type buy_tax_percentage_max: float
        :param sell_tax_percentage_min: minimum sell tax percentage
        :type sell_tax_percentage_min: float
        :param sell_tax_percentage_max: maximum sell tax percentage
        :type sell_tax_percentage_max: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pools_megafilter_serialize(
            include=include,
            page=page,
            networks=networks,
            dexes=dexes,
            sort=sort,
            fdv_usd_min=fdv_usd_min,
            fdv_usd_max=fdv_usd_max,
            reserve_in_usd_min=reserve_in_usd_min,
            reserve_in_usd_max=reserve_in_usd_max,
            h24_volume_usd_min=h24_volume_usd_min,
            h24_volume_usd_max=h24_volume_usd_max,
            pool_created_hour_min=pool_created_hour_min,
            pool_created_hour_max=pool_created_hour_max,
            tx_count_min=tx_count_min,
            tx_count_max=tx_count_max,
            tx_count_duration=tx_count_duration,
            buys_min=buys_min,
            buys_max=buys_max,
            buys_duration=buys_duration,
            sells_min=sells_min,
            sells_max=sells_max,
            sells_duration=sells_duration,
            checks=checks,
            buy_tax_percentage_min=buy_tax_percentage_min,
            buy_tax_percentage_max=buy_tax_percentage_max,
            sell_tax_percentage_min=sell_tax_percentage_min,
            sell_tax_percentage_max=sell_tax_percentage_max,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pools_megafilter_with_http_info(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        networks: Annotated[Optional[StrictStr], Field(description="filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)")] = None,
        dexes: Annotated[Optional[StrictStr], Field(description="filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h6_trending")] = None,
        fdv_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum fully diluted value in USD")] = None,
        fdv_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum fully diluted value in USD")] = None,
        reserve_in_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum reserve in USD")] = None,
        reserve_in_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum reserve in USD")] = None,
        h24_volume_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum 24hr volume in USD")] = None,
        h24_volume_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum 24hr volume in USD")] = None,
        pool_created_hour_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum pool age in hours")] = None,
        pool_created_hour_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum pool age in hours")] = None,
        tx_count_min: Annotated[Optional[StrictInt], Field(description="minimum transaction count")] = None,
        tx_count_max: Annotated[Optional[StrictInt], Field(description="maximum transaction count")] = None,
        tx_count_duration: Annotated[Optional[StrictStr], Field(description="duration for transaction count metric <br> Default value: 24h")] = None,
        buys_min: Annotated[Optional[StrictInt], Field(description="minimum number of buy transactions")] = None,
        buys_max: Annotated[Optional[StrictInt], Field(description="maximum number of buy transactions")] = None,
        buys_duration: Annotated[Optional[StrictStr], Field(description="duration for buy transactions metric <br> Default value: 24h")] = None,
        sells_min: Annotated[Optional[StrictInt], Field(description="minimum number of sell transactions")] = None,
        sells_max: Annotated[Optional[StrictInt], Field(description="maximum number of sell transactions")] = None,
        sells_duration: Annotated[Optional[StrictStr], Field(description="duration for sell transactions metric <br> Default value: 24h")] = None,
        checks: Annotated[Optional[StrictStr], Field(description="filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`")] = None,
        buy_tax_percentage_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum buy tax percentage")] = None,
        buy_tax_percentage_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum buy tax percentage")] = None,
        sell_tax_percentage_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum sell tax percentage")] = None,
        sell_tax_percentage_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum sell tax percentage")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """ Megafilter for Pools

        This endpoint allows you to **query pools based on various filters across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param networks: filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)
        :type networks: str
        :param dexes: filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)
        :type dexes: str
        :param sort: sort the pools by field <br> Default value: h6_trending
        :type sort: str
        :param fdv_usd_min: minimum fully diluted value in USD
        :type fdv_usd_min: float
        :param fdv_usd_max: maximum fully diluted value in USD
        :type fdv_usd_max: float
        :param reserve_in_usd_min: minimum reserve in USD
        :type reserve_in_usd_min: float
        :param reserve_in_usd_max: maximum reserve in USD
        :type reserve_in_usd_max: float
        :param h24_volume_usd_min: minimum 24hr volume in USD
        :type h24_volume_usd_min: float
        :param h24_volume_usd_max: maximum 24hr volume in USD
        :type h24_volume_usd_max: float
        :param pool_created_hour_min: minimum pool age in hours
        :type pool_created_hour_min: float
        :param pool_created_hour_max: maximum pool age in hours
        :type pool_created_hour_max: float
        :param tx_count_min: minimum transaction count
        :type tx_count_min: int
        :param tx_count_max: maximum transaction count
        :type tx_count_max: int
        :param tx_count_duration: duration for transaction count metric <br> Default value: 24h
        :type tx_count_duration: str
        :param buys_min: minimum number of buy transactions
        :type buys_min: int
        :param buys_max: maximum number of buy transactions
        :type buys_max: int
        :param buys_duration: duration for buy transactions metric <br> Default value: 24h
        :type buys_duration: str
        :param sells_min: minimum number of sell transactions
        :type sells_min: int
        :param sells_max: maximum number of sell transactions
        :type sells_max: int
        :param sells_duration: duration for sell transactions metric <br> Default value: 24h
        :type sells_duration: str
        :param checks: filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`
        :type checks: str
        :param buy_tax_percentage_min: minimum buy tax percentage
        :type buy_tax_percentage_min: float
        :param buy_tax_percentage_max: maximum buy tax percentage
        :type buy_tax_percentage_max: float
        :param sell_tax_percentage_min: minimum sell tax percentage
        :type sell_tax_percentage_min: float
        :param sell_tax_percentage_max: maximum sell tax percentage
        :type sell_tax_percentage_max: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pools_megafilter_serialize(
            include=include,
            page=page,
            networks=networks,
            dexes=dexes,
            sort=sort,
            fdv_usd_min=fdv_usd_min,
            fdv_usd_max=fdv_usd_max,
            reserve_in_usd_min=reserve_in_usd_min,
            reserve_in_usd_max=reserve_in_usd_max,
            h24_volume_usd_min=h24_volume_usd_min,
            h24_volume_usd_max=h24_volume_usd_max,
            pool_created_hour_min=pool_created_hour_min,
            pool_created_hour_max=pool_created_hour_max,
            tx_count_min=tx_count_min,
            tx_count_max=tx_count_max,
            tx_count_duration=tx_count_duration,
            buys_min=buys_min,
            buys_max=buys_max,
            buys_duration=buys_duration,
            sells_min=sells_min,
            sells_max=sells_max,
            sells_duration=sells_duration,
            checks=checks,
            buy_tax_percentage_min=buy_tax_percentage_min,
            buy_tax_percentage_max=buy_tax_percentage_max,
            sell_tax_percentage_min=sell_tax_percentage_min,
            sell_tax_percentage_max=sell_tax_percentage_max,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pools_megafilter_without_preload_content(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        networks: Annotated[Optional[StrictStr], Field(description="filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)")] = None,
        dexes: Annotated[Optional[StrictStr], Field(description="filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h6_trending")] = None,
        fdv_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum fully diluted value in USD")] = None,
        fdv_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum fully diluted value in USD")] = None,
        reserve_in_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum reserve in USD")] = None,
        reserve_in_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum reserve in USD")] = None,
        h24_volume_usd_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum 24hr volume in USD")] = None,
        h24_volume_usd_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum 24hr volume in USD")] = None,
        pool_created_hour_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum pool age in hours")] = None,
        pool_created_hour_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum pool age in hours")] = None,
        tx_count_min: Annotated[Optional[StrictInt], Field(description="minimum transaction count")] = None,
        tx_count_max: Annotated[Optional[StrictInt], Field(description="maximum transaction count")] = None,
        tx_count_duration: Annotated[Optional[StrictStr], Field(description="duration for transaction count metric <br> Default value: 24h")] = None,
        buys_min: Annotated[Optional[StrictInt], Field(description="minimum number of buy transactions")] = None,
        buys_max: Annotated[Optional[StrictInt], Field(description="maximum number of buy transactions")] = None,
        buys_duration: Annotated[Optional[StrictStr], Field(description="duration for buy transactions metric <br> Default value: 24h")] = None,
        sells_min: Annotated[Optional[StrictInt], Field(description="minimum number of sell transactions")] = None,
        sells_max: Annotated[Optional[StrictInt], Field(description="maximum number of sell transactions")] = None,
        sells_duration: Annotated[Optional[StrictStr], Field(description="duration for sell transactions metric <br> Default value: 24h")] = None,
        checks: Annotated[Optional[StrictStr], Field(description="filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`")] = None,
        buy_tax_percentage_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum buy tax percentage")] = None,
        buy_tax_percentage_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum buy tax percentage")] = None,
        sell_tax_percentage_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="minimum sell tax percentage")] = None,
        sell_tax_percentage_max: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="maximum sell tax percentage")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ Megafilter for Pools

        This endpoint allows you to **query pools based on various filters across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param networks: filter pools by networks, comma-separated if more than one <br> Network ID refers to [/networks](/reference/networks-list)
        :type networks: str
        :param dexes: filter pools by DEXes, comma-separated if more than one <br> DEX ID refers to [/networks/{network}/dexes](/reference/dexes-list)
        :type dexes: str
        :param sort: sort the pools by field <br> Default value: h6_trending
        :type sort: str
        :param fdv_usd_min: minimum fully diluted value in USD
        :type fdv_usd_min: float
        :param fdv_usd_max: maximum fully diluted value in USD
        :type fdv_usd_max: float
        :param reserve_in_usd_min: minimum reserve in USD
        :type reserve_in_usd_min: float
        :param reserve_in_usd_max: maximum reserve in USD
        :type reserve_in_usd_max: float
        :param h24_volume_usd_min: minimum 24hr volume in USD
        :type h24_volume_usd_min: float
        :param h24_volume_usd_max: maximum 24hr volume in USD
        :type h24_volume_usd_max: float
        :param pool_created_hour_min: minimum pool age in hours
        :type pool_created_hour_min: float
        :param pool_created_hour_max: maximum pool age in hours
        :type pool_created_hour_max: float
        :param tx_count_min: minimum transaction count
        :type tx_count_min: int
        :param tx_count_max: maximum transaction count
        :type tx_count_max: int
        :param tx_count_duration: duration for transaction count metric <br> Default value: 24h
        :type tx_count_duration: str
        :param buys_min: minimum number of buy transactions
        :type buys_min: int
        :param buys_max: maximum number of buy transactions
        :type buys_max: int
        :param buys_duration: duration for buy transactions metric <br> Default value: 24h
        :type buys_duration: str
        :param sells_min: minimum number of sell transactions
        :type sells_min: int
        :param sells_max: maximum number of sell transactions
        :type sells_max: int
        :param sells_duration: duration for sell transactions metric <br> Default value: 24h
        :type sells_duration: str
        :param checks: filter options for various checks, comma-separated if more than one <br> Available values: `no_honeypot`, `good_gt_score`, `on_coingecko`, `has_social`
        :type checks: str
        :param buy_tax_percentage_min: minimum buy tax percentage
        :type buy_tax_percentage_min: float
        :param buy_tax_percentage_max: maximum buy tax percentage
        :type buy_tax_percentage_max: float
        :param sell_tax_percentage_min: minimum sell tax percentage
        :type sell_tax_percentage_min: float
        :param sell_tax_percentage_max: maximum sell tax percentage
        :type sell_tax_percentage_max: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pools_megafilter_serialize(
            include=include,
            page=page,
            networks=networks,
            dexes=dexes,
            sort=sort,
            fdv_usd_min=fdv_usd_min,
            fdv_usd_max=fdv_usd_max,
            reserve_in_usd_min=reserve_in_usd_min,
            reserve_in_usd_max=reserve_in_usd_max,
            h24_volume_usd_min=h24_volume_usd_min,
            h24_volume_usd_max=h24_volume_usd_max,
            pool_created_hour_min=pool_created_hour_min,
            pool_created_hour_max=pool_created_hour_max,
            tx_count_min=tx_count_min,
            tx_count_max=tx_count_max,
            tx_count_duration=tx_count_duration,
            buys_min=buys_min,
            buys_max=buys_max,
            buys_duration=buys_duration,
            sells_min=sells_min,
            sells_max=sells_max,
            sells_duration=sells_duration,
            checks=checks,
            buy_tax_percentage_min=buy_tax_percentage_min,
            buy_tax_percentage_max=buy_tax_percentage_max,
            sell_tax_percentage_min=sell_tax_percentage_min,
            sell_tax_percentage_max=sell_tax_percentage_max,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pools_megafilter_serialize(
        self,
        include,
        page,
        networks,
        dexes,
        sort,
        fdv_usd_min,
        fdv_usd_max,
        reserve_in_usd_min,
        reserve_in_usd_max,
        h24_volume_usd_min,
        h24_volume_usd_max,
        pool_created_hour_min,
        pool_created_hour_max,
        tx_count_min,
        tx_count_max,
        tx_count_duration,
        buys_min,
        buys_max,
        buys_duration,
        sells_min,
        sells_max,
        sells_duration,
        checks,
        buy_tax_percentage_min,
        buy_tax_percentage_max,
        sell_tax_percentage_min,
        sell_tax_percentage_max,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if networks is not None:
            
            _query_params.append(('networks', networks))
            
        if dexes is not None:
            
            _query_params.append(('dexes', dexes))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fdv_usd_min is not None:
            
            _query_params.append(('fdv_usd_min', fdv_usd_min))
            
        if fdv_usd_max is not None:
            
            _query_params.append(('fdv_usd_max', fdv_usd_max))
            
        if reserve_in_usd_min is not None:
            
            _query_params.append(('reserve_in_usd_min', reserve_in_usd_min))
            
        if reserve_in_usd_max is not None:
            
            _query_params.append(('reserve_in_usd_max', reserve_in_usd_max))
            
        if h24_volume_usd_min is not None:
            
            _query_params.append(('h24_volume_usd_min', h24_volume_usd_min))
            
        if h24_volume_usd_max is not None:
            
            _query_params.append(('h24_volume_usd_max', h24_volume_usd_max))
            
        if pool_created_hour_min is not None:
            
            _query_params.append(('pool_created_hour_min', pool_created_hour_min))
            
        if pool_created_hour_max is not None:
            
            _query_params.append(('pool_created_hour_max', pool_created_hour_max))
            
        if tx_count_min is not None:
            
            _query_params.append(('tx_count_min', tx_count_min))
            
        if tx_count_max is not None:
            
            _query_params.append(('tx_count_max', tx_count_max))
            
        if tx_count_duration is not None:
            
            _query_params.append(('tx_count_duration', tx_count_duration))
            
        if buys_min is not None:
            
            _query_params.append(('buys_min', buys_min))
            
        if buys_max is not None:
            
            _query_params.append(('buys_max', buys_max))
            
        if buys_duration is not None:
            
            _query_params.append(('buys_duration', buys_duration))
            
        if sells_min is not None:
            
            _query_params.append(('sells_min', sells_min))
            
        if sells_max is not None:
            
            _query_params.append(('sells_max', sells_max))
            
        if sells_duration is not None:
            
            _query_params.append(('sells_duration', sells_duration))
            
        if checks is not None:
            
            _query_params.append(('checks', checks))
            
        if buy_tax_percentage_min is not None:
            
            _query_params.append(('buy_tax_percentage_min', buy_tax_percentage_min))
            
        if buy_tax_percentage_max is not None:
            
            _query_params.append(('buy_tax_percentage_max', buy_tax_percentage_max))
            
        if sell_tax_percentage_min is not None:
            
            _query_params.append(('sell_tax_percentage_min', sell_tax_percentage_min))
            
        if sell_tax_percentage_max is not None:
            
            _query_params.append(('sell_tax_percentage_max', sell_tax_percentage_max))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/pools/megafilter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_pools(
        self,
        query: Annotated[Optional[StrictStr], Field(description="search query")] = None,
        network: Annotated[Optional[StrictStr], Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")] = None,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """Search Pools

        This endpoint allows you to **search for pools on a network**

        :param query: search query
        :type query: str
        :param network: network ID <br> *refers to [/networks](/reference/networks-list)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_pools_serialize(
            query=query,
            network=network,
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_pools_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="search query")] = None,
        network: Annotated[Optional[StrictStr], Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")] = None,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """Search Pools

        This endpoint allows you to **search for pools on a network**

        :param query: search query
        :type query: str
        :param network: network ID <br> *refers to [/networks](/reference/networks-list)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_pools_serialize(
            query=query,
            network=network,
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_pools_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="search query")] = None,
        network: Annotated[Optional[StrictStr], Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")] = None,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Pools

        This endpoint allows you to **search for pools on a network**

        :param query: search query
        :type query: str
        :param network: network ID <br> *refers to [/networks](/reference/networks-list)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_pools_serialize(
            query=query,
            network=network,
            include=include,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_pools_serialize(
        self,
        query,
        network,
        include,
        page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/search/pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def top_pools_dex(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        dex: Annotated[StrictStr, Field(description="DEX ID <br> *refers to [/networks/{network}/dexes](/reference/dexes-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h24_tx_count_desc")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """Top Pools by Dex

        This endpoint allows you to **query all the top pools based on the provided network and decentralized exchange (DEX)**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param dex: DEX ID <br> *refers to [/networks/{network}/dexes](/reference/dexes-list) (required)
        :type dex: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param sort: sort the pools by field <br> Default value: h24_tx_count_desc
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_pools_dex_serialize(
            network=network,
            dex=dex,
            include=include,
            page=page,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def top_pools_dex_with_http_info(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        dex: Annotated[StrictStr, Field(description="DEX ID <br> *refers to [/networks/{network}/dexes](/reference/dexes-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h24_tx_count_desc")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """Top Pools by Dex

        This endpoint allows you to **query all the top pools based on the provided network and decentralized exchange (DEX)**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param dex: DEX ID <br> *refers to [/networks/{network}/dexes](/reference/dexes-list) (required)
        :type dex: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param sort: sort the pools by field <br> Default value: h24_tx_count_desc
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_pools_dex_serialize(
            network=network,
            dex=dex,
            include=include,
            page=page,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def top_pools_dex_without_preload_content(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        dex: Annotated[StrictStr, Field(description="DEX ID <br> *refers to [/networks/{network}/dexes](/reference/dexes-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h24_tx_count_desc")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Top Pools by Dex

        This endpoint allows you to **query all the top pools based on the provided network and decentralized exchange (DEX)**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param dex: DEX ID <br> *refers to [/networks/{network}/dexes](/reference/dexes-list) (required)
        :type dex: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param sort: sort the pools by field <br> Default value: h24_tx_count_desc
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_pools_dex_serialize(
            network=network,
            dex=dex,
            include=include,
            page=page,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _top_pools_dex_serialize(
        self,
        network,
        dex,
        include,
        page,
        sort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network is not None:
            _path_params['network'] = network
        if dex is not None:
            _path_params['dex'] = dex
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/{network}/dexes/{dex}/pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def top_pools_network(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h24_tx_count_desc")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """Top Pools by Network

        This endpoint allows you to **query all the top pools based on the provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param sort: sort the pools by field <br> Default value: h24_tx_count_desc
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def top_pools_network_with_http_info(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h24_tx_count_desc")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """Top Pools by Network

        This endpoint allows you to **query all the top pools based on the provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param sort: sort the pools by field <br> Default value: h24_tx_count_desc
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def top_pools_network_without_preload_content(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="sort the pools by field <br> Default value: h24_tx_count_desc")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Top Pools by Network

        This endpoint allows you to **query all the top pools based on the provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param sort: sort the pools by field <br> Default value: h24_tx_count_desc
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _top_pools_network_serialize(
        self,
        network,
        include,
        page,
        sort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/{network}/pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trending_pools_list(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="duration to sort trending list by <br> Default value: 24h")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """Trending Pools List

        This endpoint allows you to **query all the trending pools across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param duration: duration to sort trending list by <br> Default value: 24h
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trending_pools_list_serialize(
            include=include,
            page=page,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trending_pools_list_with_http_info(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="duration to sort trending list by <br> Default value: 24h")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """Trending Pools List

        This endpoint allows you to **query all the trending pools across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param duration: duration to sort trending list by <br> Default value: 24h
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trending_pools_list_serialize(
            include=include,
            page=page,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trending_pools_list_without_preload_content(
        self,
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="duration to sort trending list by <br> Default value: 24h")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trending Pools List

        This endpoint allows you to **query all the trending pools across all networks on GeckoTerminal**

        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`, `network`. <br> Example: `base_token` or `base_token,dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param duration: duration to sort trending list by <br> Default value: 24h
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trending_pools_list_serialize(
            include=include,
            page=page,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trending_pools_list_serialize(
        self,
        include,
        page,
        duration,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/trending_pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trending_pools_network(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="duration to sort trending list by <br> Default value: 24h")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Pool:
        """Trending Pools by Network

        This endpoint allows you to **query the trending pools based on the provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param duration: duration to sort trending list by <br> Default value: 24h
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trending_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trending_pools_network_with_http_info(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="duration to sort trending list by <br> Default value: 24h")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Pool]:
        """Trending Pools by Network

        This endpoint allows you to **query the trending pools based on the provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param duration: duration to sort trending list by <br> Default value: 24h
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trending_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trending_pools_network_without_preload_content(
        self,
        network: Annotated[StrictStr, Field(description="network ID <br> *refers to [/networks](/reference/networks-list)")],
        include: Annotated[Optional[StrictStr], Field(description="attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`")] = None,
        page: Annotated[Optional[StrictInt], Field(description="page through results <br> Default value: 1")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="duration to sort trending list by <br> Default value: 24h")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trending Pools by Network

        This endpoint allows you to **query the trending pools based on the provided network**

        :param network: network ID <br> *refers to [/networks](/reference/networks-list) (required)
        :type network: str
        :param include: attributes to include, comma-separated if more than one to include <br> Available values: `base_token`, `quote_token`, `dex`
        :type include: str
        :param page: page through results <br> Default value: 1
        :type page: int
        :param duration: duration to sort trending list by <br> Default value: 24h
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trending_pools_network_serialize(
            network=network,
            include=include,
            page=page,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Pool",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trending_pools_network_serialize(
        self,
        network,
        include,
        page,
        duration,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network is not None:
            _path_params['network'] = network
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/onchain/networks/{network}/trending_pools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


