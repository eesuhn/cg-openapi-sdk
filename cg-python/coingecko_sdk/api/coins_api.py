# coding: utf-8

"""
    CoinGecko API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v3.1.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from coingecko_sdk.models.coins_historical_data import CoinsHistoricalData
from coingecko_sdk.models.coins_id import CoinsID
from coingecko_sdk.models.coins_list_inner import CoinsListInner
from coingecko_sdk.models.coins_list_new_inner import CoinsListNewInner
from coingecko_sdk.models.coins_market_chart import CoinsMarketChart
from coingecko_sdk.models.coins_market_chart_range import CoinsMarketChartRange
from coingecko_sdk.models.coins_markets import CoinsMarkets
from coingecko_sdk.models.coins_tickers import CoinsTickers
from coingecko_sdk.models.top_gainers_losers_inner import TopGainersLosersInner

from coingecko_sdk.api_client import ApiClient, RequestSerialized
from coingecko_sdk.api_response import ApiResponse
from coingecko_sdk.rest import RESTResponseType


class CoinsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def coins_id(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        localization: Annotated[Optional[StrictBool], Field(description="include all the localized languages in the response, default: true")] = None,
        tickers: Annotated[Optional[StrictBool], Field(description="include tickers data, default: true")] = None,
        market_data: Annotated[Optional[StrictBool], Field(description="include market data, default: true")] = None,
        community_data: Annotated[Optional[StrictBool], Field(description="include community data, default: true")] = None,
        developer_data: Annotated[Optional[StrictBool], Field(description="include developer data, default: true")] = None,
        sparkline: Annotated[Optional[StrictBool], Field(description="include sparkline 7 days data, default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoinsID:
        """Coin Data by ID

        This endpoint allows you to **query all the metadata (image,  websites, socials, description, contract address, etc.) and  market data (price, ATH, exchange tickers, etc.) of a coin  from the CoinGecko coin page based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param localization: include all the localized languages in the response, default: true
        :type localization: bool
        :param tickers: include tickers data, default: true
        :type tickers: bool
        :param market_data: include market data, default: true
        :type market_data: bool
        :param community_data: include community data, default: true
        :type community_data: bool
        :param developer_data: include developer data, default: true
        :type developer_data: bool
        :param sparkline: include sparkline 7 days data, default: false
        :type sparkline: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_serialize(
            id=id,
            localization=localization,
            tickers=tickers,
            market_data=market_data,
            community_data=community_data,
            developer_data=developer_data,
            sparkline=sparkline,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsID",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        localization: Annotated[Optional[StrictBool], Field(description="include all the localized languages in the response, default: true")] = None,
        tickers: Annotated[Optional[StrictBool], Field(description="include tickers data, default: true")] = None,
        market_data: Annotated[Optional[StrictBool], Field(description="include market data, default: true")] = None,
        community_data: Annotated[Optional[StrictBool], Field(description="include community data, default: true")] = None,
        developer_data: Annotated[Optional[StrictBool], Field(description="include developer data, default: true")] = None,
        sparkline: Annotated[Optional[StrictBool], Field(description="include sparkline 7 days data, default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoinsID]:
        """Coin Data by ID

        This endpoint allows you to **query all the metadata (image,  websites, socials, description, contract address, etc.) and  market data (price, ATH, exchange tickers, etc.) of a coin  from the CoinGecko coin page based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param localization: include all the localized languages in the response, default: true
        :type localization: bool
        :param tickers: include tickers data, default: true
        :type tickers: bool
        :param market_data: include market data, default: true
        :type market_data: bool
        :param community_data: include community data, default: true
        :type community_data: bool
        :param developer_data: include developer data, default: true
        :type developer_data: bool
        :param sparkline: include sparkline 7 days data, default: false
        :type sparkline: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_serialize(
            id=id,
            localization=localization,
            tickers=tickers,
            market_data=market_data,
            community_data=community_data,
            developer_data=developer_data,
            sparkline=sparkline,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsID",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        localization: Annotated[Optional[StrictBool], Field(description="include all the localized languages in the response, default: true")] = None,
        tickers: Annotated[Optional[StrictBool], Field(description="include tickers data, default: true")] = None,
        market_data: Annotated[Optional[StrictBool], Field(description="include market data, default: true")] = None,
        community_data: Annotated[Optional[StrictBool], Field(description="include community data, default: true")] = None,
        developer_data: Annotated[Optional[StrictBool], Field(description="include developer data, default: true")] = None,
        sparkline: Annotated[Optional[StrictBool], Field(description="include sparkline 7 days data, default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coin Data by ID

        This endpoint allows you to **query all the metadata (image,  websites, socials, description, contract address, etc.) and  market data (price, ATH, exchange tickers, etc.) of a coin  from the CoinGecko coin page based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param localization: include all the localized languages in the response, default: true
        :type localization: bool
        :param tickers: include tickers data, default: true
        :type tickers: bool
        :param market_data: include market data, default: true
        :type market_data: bool
        :param community_data: include community data, default: true
        :type community_data: bool
        :param developer_data: include developer data, default: true
        :type developer_data: bool
        :param sparkline: include sparkline 7 days data, default: false
        :type sparkline: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_serialize(
            id=id,
            localization=localization,
            tickers=tickers,
            market_data=market_data,
            community_data=community_data,
            developer_data=developer_data,
            sparkline=sparkline,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsID",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_serialize(
        self,
        id,
        localization,
        tickers,
        market_data,
        community_data,
        developer_data,
        sparkline,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if localization is not None:
            
            _query_params.append(('localization', localization))
            
        if tickers is not None:
            
            _query_params.append(('tickers', tickers))
            
        if market_data is not None:
            
            _query_params.append(('market_data', market_data))
            
        if community_data is not None:
            
            _query_params.append(('community_data', community_data))
            
        if developer_data is not None:
            
            _query_params.append(('developer_data', developer_data))
            
        if sparkline is not None:
            
            _query_params.append(('sparkline', sparkline))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_circulating_supply_chart(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> Valid values: any integer or `max`")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[float]]:
        """👑 Circulating Supply Chart by ID

        This endpoint allows you to **query historical circulating supply of a coin by number of days away from now based on provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param days: data up to number of days ago <br> Valid values: any integer or `max` (required)
        :type days: str
        :param interval: data interval
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_circulating_supply_chart_serialize(
            id=id,
            days=days,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_circulating_supply_chart_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> Valid values: any integer or `max`")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[float]]]:
        """👑 Circulating Supply Chart by ID

        This endpoint allows you to **query historical circulating supply of a coin by number of days away from now based on provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param days: data up to number of days ago <br> Valid values: any integer or `max` (required)
        :type days: str
        :param interval: data interval
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_circulating_supply_chart_serialize(
            id=id,
            days=days,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_circulating_supply_chart_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> Valid values: any integer or `max`")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """👑 Circulating Supply Chart by ID

        This endpoint allows you to **query historical circulating supply of a coin by number of days away from now based on provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param days: data up to number of days ago <br> Valid values: any integer or `max` (required)
        :type days: str
        :param interval: data interval
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_circulating_supply_chart_serialize(
            id=id,
            days=days,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_circulating_supply_chart_serialize(
        self,
        id,
        days,
        interval,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if days is not None:
            
            _query_params.append(('days', days))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/circulating_supply_chart',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_circulating_supply_chart_range(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[float]]:
        """👑 Circulating Supply Chart within Time Range by ID

        This endpoint allows you to **query historical circulating supply of a coin, within a range of timestamp based on the provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp  (required)
        :type to: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_circulating_supply_chart_range_serialize(
            id=id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_circulating_supply_chart_range_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[float]]]:
        """👑 Circulating Supply Chart within Time Range by ID

        This endpoint allows you to **query historical circulating supply of a coin, within a range of timestamp based on the provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp  (required)
        :type to: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_circulating_supply_chart_range_serialize(
            id=id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_circulating_supply_chart_range_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """👑 Circulating Supply Chart within Time Range by ID

        This endpoint allows you to **query historical circulating supply of a coin, within a range of timestamp based on the provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp  (required)
        :type to: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_circulating_supply_chart_range_serialize(
            id=id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_circulating_supply_chart_range_serialize(
        self,
        id,
        var_from,
        to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if to is not None:
            
            _query_params.append(('to', to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/circulating_supply_chart/range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_history(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_date: Annotated[StrictStr, Field(description="the date of data snapshot <br> Format: `dd-mm-yyyy`")],
        localization: Annotated[Optional[StrictBool], Field(description="include all the localized languages in response, default: true")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoinsHistoricalData:
        """Coin Historical Data by ID

        This endpoint allows you to **query the historical data (price, market cap, 24hrs volume, ...) at a given date for a coin based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_date: the date of data snapshot <br> Format: `dd-mm-yyyy` (required)
        :type var_date: str
        :param localization: include all the localized languages in response, default: true
        :type localization: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_history_serialize(
            id=id,
            var_date=var_date,
            localization=localization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsHistoricalData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_history_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_date: Annotated[StrictStr, Field(description="the date of data snapshot <br> Format: `dd-mm-yyyy`")],
        localization: Annotated[Optional[StrictBool], Field(description="include all the localized languages in response, default: true")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoinsHistoricalData]:
        """Coin Historical Data by ID

        This endpoint allows you to **query the historical data (price, market cap, 24hrs volume, ...) at a given date for a coin based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_date: the date of data snapshot <br> Format: `dd-mm-yyyy` (required)
        :type var_date: str
        :param localization: include all the localized languages in response, default: true
        :type localization: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_history_serialize(
            id=id,
            var_date=var_date,
            localization=localization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsHistoricalData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_history_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_date: Annotated[StrictStr, Field(description="the date of data snapshot <br> Format: `dd-mm-yyyy`")],
        localization: Annotated[Optional[StrictBool], Field(description="include all the localized languages in response, default: true")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coin Historical Data by ID

        This endpoint allows you to **query the historical data (price, market cap, 24hrs volume, ...) at a given date for a coin based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_date: the date of data snapshot <br> Format: `dd-mm-yyyy` (required)
        :type var_date: str
        :param localization: include all the localized languages in response, default: true
        :type localization: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_history_serialize(
            id=id,
            var_date=var_date,
            localization=localization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsHistoricalData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_history_serialize(
        self,
        id,
        var_date,
        localization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if localization is not None:
            
            _query_params.append(('localization', localization))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_market_chart(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> You may use any integer or `max` for number of days")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoinsMarketChart:
        """Coin Historical Chart Data by ID

        This endpoint allows you to **get the historical chart data of a coin including time in UNIX, price, market cap and 24hr volume based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param days: data up to number of days ago <br> You may use any integer or `max` for number of days (required)
        :type days: str
        :param interval: data interval, leave empty for auto granularity
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_market_chart_serialize(
            id=id,
            vs_currency=vs_currency,
            days=days,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarketChart",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_market_chart_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> You may use any integer or `max` for number of days")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoinsMarketChart]:
        """Coin Historical Chart Data by ID

        This endpoint allows you to **get the historical chart data of a coin including time in UNIX, price, market cap and 24hr volume based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param days: data up to number of days ago <br> You may use any integer or `max` for number of days (required)
        :type days: str
        :param interval: data interval, leave empty for auto granularity
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_market_chart_serialize(
            id=id,
            vs_currency=vs_currency,
            days=days,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarketChart",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_market_chart_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> You may use any integer or `max` for number of days")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coin Historical Chart Data by ID

        This endpoint allows you to **get the historical chart data of a coin including time in UNIX, price, market cap and 24hr volume based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param days: data up to number of days ago <br> You may use any integer or `max` for number of days (required)
        :type days: str
        :param interval: data interval, leave empty for auto granularity
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_market_chart_serialize(
            id=id,
            vs_currency=vs_currency,
            days=days,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarketChart",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_market_chart_serialize(
        self,
        id,
        vs_currency,
        days,
        interval,
        precision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if vs_currency is not None:
            
            _query_params.append(('vs_currency', vs_currency))
            
        if days is not None:
            
            _query_params.append(('days', days))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        if precision is not None:
            
            _query_params.append(('precision', precision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/market_chart',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_market_chart_range(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity ")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoinsMarketChartRange:
        """Coin Historical Chart Data within Time Range by ID

        This endpoint allows you to **get the historical chart data of a coin within certain time range in UNIX along with price, market cap and 24hr volume based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp (required)
        :type to: float
        :param interval: data interval, leave empty for auto granularity 
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_market_chart_range_serialize(
            id=id,
            vs_currency=vs_currency,
            var_from=var_from,
            to=to,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarketChartRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_market_chart_range_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity ")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoinsMarketChartRange]:
        """Coin Historical Chart Data within Time Range by ID

        This endpoint allows you to **get the historical chart data of a coin within certain time range in UNIX along with price, market cap and 24hr volume based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp (required)
        :type to: float
        :param interval: data interval, leave empty for auto granularity 
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_market_chart_range_serialize(
            id=id,
            vs_currency=vs_currency,
            var_from=var_from,
            to=to,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarketChartRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_market_chart_range_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity ")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coin Historical Chart Data within Time Range by ID

        This endpoint allows you to **get the historical chart data of a coin within certain time range in UNIX along with price, market cap and 24hr volume based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp (required)
        :type to: float
        :param interval: data interval, leave empty for auto granularity 
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_market_chart_range_serialize(
            id=id,
            vs_currency=vs_currency,
            var_from=var_from,
            to=to,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarketChartRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_market_chart_range_serialize(
        self,
        id,
        vs_currency,
        var_from,
        to,
        interval,
        precision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if vs_currency is not None:
            
            _query_params.append(('vs_currency', vs_currency))
            
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if to is not None:
            
            _query_params.append(('to', to))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        if precision is not None:
            
            _query_params.append(('precision', precision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/market_chart/range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_ohlc(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago ")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[float]]:
        """Coin OHLC Chart by ID

        This endpoint allows you to **get the OHLC chart (Open, High, Low, Close) of a coin based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param days: data up to number of days ago  (required)
        :type days: str
        :param interval: data interval, leave empty for auto granularity
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_ohlc_serialize(
            id=id,
            vs_currency=vs_currency,
            days=days,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_ohlc_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago ")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[float]]]:
        """Coin OHLC Chart by ID

        This endpoint allows you to **get the OHLC chart (Open, High, Low, Close) of a coin based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param days: data up to number of days ago  (required)
        :type days: str
        :param interval: data interval, leave empty for auto granularity
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_ohlc_serialize(
            id=id,
            vs_currency=vs_currency,
            days=days,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_ohlc_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago ")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval, leave empty for auto granularity")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coin OHLC Chart by ID

        This endpoint allows you to **get the OHLC chart (Open, High, Low, Close) of a coin based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param days: data up to number of days ago  (required)
        :type days: str
        :param interval: data interval, leave empty for auto granularity
        :type interval: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_ohlc_serialize(
            id=id,
            vs_currency=vs_currency,
            days=days,
            interval=interval,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_ohlc_serialize(
        self,
        id,
        vs_currency,
        days,
        interval,
        precision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if vs_currency is not None:
            
            _query_params.append(('vs_currency', vs_currency))
            
        if days is not None:
            
            _query_params.append(('days', days))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        if precision is not None:
            
            _query_params.append(('precision', precision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/ohlc',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_ohlc_range(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp")],
        interval: Annotated[StrictStr, Field(description="data interval")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[float]]:
        """💼 Coin OHLC Chart within Time Range by ID

        This endpoint allows you to **get the OHLC chart (Open, High, Low, Close) of a coin within a range of timestamp based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param var_from: starting date in UNIX timestamp (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp (required)
        :type to: float
        :param interval: data interval (required)
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_ohlc_range_serialize(
            id=id,
            vs_currency=vs_currency,
            var_from=var_from,
            to=to,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_ohlc_range_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp")],
        interval: Annotated[StrictStr, Field(description="data interval")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[float]]]:
        """💼 Coin OHLC Chart within Time Range by ID

        This endpoint allows you to **get the OHLC chart (Open, High, Low, Close) of a coin within a range of timestamp based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param var_from: starting date in UNIX timestamp (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp (required)
        :type to: float
        :param interval: data interval (required)
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_ohlc_range_serialize(
            id=id,
            vs_currency=vs_currency,
            var_from=var_from,
            to=to,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_ohlc_range_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        vs_currency: Annotated[StrictStr, Field(description="target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp")],
        interval: Annotated[StrictStr, Field(description="data interval")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """💼 Coin OHLC Chart within Time Range by ID

        This endpoint allows you to **get the OHLC chart (Open, High, Low, Close) of a coin within a range of timestamp based on particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param vs_currency: target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param var_from: starting date in UNIX timestamp (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp (required)
        :type to: float
        :param interval: data interval (required)
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_ohlc_range_serialize(
            id=id,
            vs_currency=vs_currency,
            var_from=var_from,
            to=to,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_ohlc_range_serialize(
        self,
        id,
        vs_currency,
        var_from,
        to,
        interval,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if vs_currency is not None:
            
            _query_params.append(('vs_currency', vs_currency))
            
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if to is not None:
            
            _query_params.append(('to', to))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/ohlc/range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_tickers(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        exchange_ids: Annotated[Optional[StrictStr], Field(description="exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).")] = None,
        include_exchange_logo: Annotated[Optional[StrictBool], Field(description="include exchange logo, default: false")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="page through results")] = None,
        order: Annotated[Optional[StrictStr], Field(description="use this to sort the order of responses, default: trust_score_desc")] = None,
        depth: Annotated[Optional[StrictBool], Field(description="include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoinsTickers:
        """Coin Tickers by ID

        This endpoint allows you to **query the coin tickers on both centralized exchange (CEX) and decentralized exchange (DEX) based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param exchange_ids: exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).
        :type exchange_ids: str
        :param include_exchange_logo: include exchange logo, default: false
        :type include_exchange_logo: bool
        :param page: page through results
        :type page: float
        :param order: use this to sort the order of responses, default: trust_score_desc
        :type order: str
        :param depth: include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false
        :type depth: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_tickers_serialize(
            id=id,
            exchange_ids=exchange_ids,
            include_exchange_logo=include_exchange_logo,
            page=page,
            order=order,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsTickers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_tickers_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        exchange_ids: Annotated[Optional[StrictStr], Field(description="exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).")] = None,
        include_exchange_logo: Annotated[Optional[StrictBool], Field(description="include exchange logo, default: false")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="page through results")] = None,
        order: Annotated[Optional[StrictStr], Field(description="use this to sort the order of responses, default: trust_score_desc")] = None,
        depth: Annotated[Optional[StrictBool], Field(description="include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoinsTickers]:
        """Coin Tickers by ID

        This endpoint allows you to **query the coin tickers on both centralized exchange (CEX) and decentralized exchange (DEX) based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param exchange_ids: exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).
        :type exchange_ids: str
        :param include_exchange_logo: include exchange logo, default: false
        :type include_exchange_logo: bool
        :param page: page through results
        :type page: float
        :param order: use this to sort the order of responses, default: trust_score_desc
        :type order: str
        :param depth: include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false
        :type depth: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_tickers_serialize(
            id=id,
            exchange_ids=exchange_ids,
            include_exchange_logo=include_exchange_logo,
            page=page,
            order=order,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsTickers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_tickers_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        exchange_ids: Annotated[Optional[StrictStr], Field(description="exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).")] = None,
        include_exchange_logo: Annotated[Optional[StrictBool], Field(description="include exchange logo, default: false")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="page through results")] = None,
        order: Annotated[Optional[StrictStr], Field(description="use this to sort the order of responses, default: trust_score_desc")] = None,
        depth: Annotated[Optional[StrictBool], Field(description="include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coin Tickers by ID

        This endpoint allows you to **query the coin tickers on both centralized exchange (CEX) and decentralized exchange (DEX) based on a particular coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param exchange_ids: exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).
        :type exchange_ids: str
        :param include_exchange_logo: include exchange logo, default: false
        :type include_exchange_logo: bool
        :param page: page through results
        :type page: float
        :param order: use this to sort the order of responses, default: trust_score_desc
        :type order: str
        :param depth: include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false
        :type depth: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_tickers_serialize(
            id=id,
            exchange_ids=exchange_ids,
            include_exchange_logo=include_exchange_logo,
            page=page,
            order=order,
            depth=depth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsTickers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_tickers_serialize(
        self,
        id,
        exchange_ids,
        include_exchange_logo,
        page,
        order,
        depth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if exchange_ids is not None:
            
            _query_params.append(('exchange_ids', exchange_ids))
            
        if include_exchange_logo is not None:
            
            _query_params.append(('include_exchange_logo', include_exchange_logo))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/tickers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_total_supply_chart(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> Valid values: any integer or `max`")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[float]]:
        """👑 Total Supply Chart by ID

        This endpoint allows you to **query historical total supply of a coin by number of days away from now based on provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param days: data up to number of days ago <br> Valid values: any integer or `max` (required)
        :type days: str
        :param interval: data interval
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_total_supply_chart_serialize(
            id=id,
            days=days,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_total_supply_chart_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> Valid values: any integer or `max`")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[float]]]:
        """👑 Total Supply Chart by ID

        This endpoint allows you to **query historical total supply of a coin by number of days away from now based on provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param days: data up to number of days ago <br> Valid values: any integer or `max` (required)
        :type days: str
        :param interval: data interval
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_total_supply_chart_serialize(
            id=id,
            days=days,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_total_supply_chart_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        days: Annotated[StrictStr, Field(description="data up to number of days ago <br> Valid values: any integer or `max`")],
        interval: Annotated[Optional[StrictStr], Field(description="data interval")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """👑 Total Supply Chart by ID

        This endpoint allows you to **query historical total supply of a coin by number of days away from now based on provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param days: data up to number of days ago <br> Valid values: any integer or `max` (required)
        :type days: str
        :param interval: data interval
        :type interval: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_total_supply_chart_serialize(
            id=id,
            days=days,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_total_supply_chart_serialize(
        self,
        id,
        days,
        interval,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if days is not None:
            
            _query_params.append(('days', days))
            
        if interval is not None:
            
            _query_params.append(('interval', interval))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/total_supply_chart',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_id_total_supply_chart_range(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[List[float]]:
        """👑 Total Supply Chart within time range by ID

        This endpoint allows you to **query historical total supply of a coin, within a range of timestamp based on the provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp  (required)
        :type to: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_total_supply_chart_range_serialize(
            id=id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_id_total_supply_chart_range_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[List[float]]]:
        """👑 Total Supply Chart within time range by ID

        This endpoint allows you to **query historical total supply of a coin, within a range of timestamp based on the provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp  (required)
        :type to: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_total_supply_chart_range_serialize(
            id=id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_id_total_supply_chart_range_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="coin ID <br> *refers to [`/coins/list`](/reference/coins-list).")],
        var_from: Annotated[Union[StrictFloat, StrictInt], Field(description="starting date in UNIX timestamp ")],
        to: Annotated[Union[StrictFloat, StrictInt], Field(description="ending date in UNIX timestamp ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """👑 Total Supply Chart within time range by ID

        This endpoint allows you to **query historical total supply of a coin, within a range of timestamp based on the provided coin ID**

        :param id: coin ID <br> *refers to [`/coins/list`](/reference/coins-list). (required)
        :type id: str
        :param var_from: starting date in UNIX timestamp  (required)
        :type var_from: float
        :param to: ending date in UNIX timestamp  (required)
        :type to: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_id_total_supply_chart_range_serialize(
            id=id,
            var_from=var_from,
            to=to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[List[float]]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_id_total_supply_chart_range_serialize(
        self,
        id,
        var_from,
        to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if to is not None:
            
            _query_params.append(('to', to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/{id}/total_supply_chart/range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_list(
        self,
        include_platform: Annotated[Optional[StrictBool], Field(description="include platform and token's contract addresses, default: false")] = None,
        status: Annotated[Optional[StrictStr], Field(description="filter by status of coins, default: active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[CoinsListInner]:
        """Coins List (ID Map)

        This endpoint allows you to **query all the supported coins on CoinGecko with coins ID, name and symbol**

        :param include_platform: include platform and token's contract addresses, default: false
        :type include_platform: bool
        :param status: filter by status of coins, default: active
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_list_serialize(
            include_platform=include_platform,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoinsListInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_list_with_http_info(
        self,
        include_platform: Annotated[Optional[StrictBool], Field(description="include platform and token's contract addresses, default: false")] = None,
        status: Annotated[Optional[StrictStr], Field(description="filter by status of coins, default: active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[CoinsListInner]]:
        """Coins List (ID Map)

        This endpoint allows you to **query all the supported coins on CoinGecko with coins ID, name and symbol**

        :param include_platform: include platform and token's contract addresses, default: false
        :type include_platform: bool
        :param status: filter by status of coins, default: active
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_list_serialize(
            include_platform=include_platform,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoinsListInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_list_without_preload_content(
        self,
        include_platform: Annotated[Optional[StrictBool], Field(description="include platform and token's contract addresses, default: false")] = None,
        status: Annotated[Optional[StrictStr], Field(description="filter by status of coins, default: active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coins List (ID Map)

        This endpoint allows you to **query all the supported coins on CoinGecko with coins ID, name and symbol**

        :param include_platform: include platform and token's contract addresses, default: false
        :type include_platform: bool
        :param status: filter by status of coins, default: active
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_list_serialize(
            include_platform=include_platform,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoinsListInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_list_serialize(
        self,
        include_platform,
        status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_platform is not None:
            
            _query_params.append(('include_platform', include_platform))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_list_new(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[CoinsListNewInner]:
        """💼 Recently Added Coins

        This endpoint allows you to **query the latest 200 coins that recently listed on CoinGecko**

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_list_new_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoinsListNewInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_list_new_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[CoinsListNewInner]]:
        """💼 Recently Added Coins

        This endpoint allows you to **query the latest 200 coins that recently listed on CoinGecko**

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_list_new_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoinsListNewInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_list_new_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """💼 Recently Added Coins

        This endpoint allows you to **query the latest 200 coins that recently listed on CoinGecko**

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_list_new_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoinsListNewInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_list_new_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/list/new',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_markets(
        self,
        vs_currency: Annotated[StrictStr, Field(description="target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        ids: Annotated[Optional[StrictStr], Field(description="coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).")] = None,
        category: Annotated[Optional[StrictStr], Field(description="filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).")] = None,
        order: Annotated[Optional[StrictStr], Field(description="sort result by field, default: market_cap_desc")] = None,
        per_page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="total results per page, default: 100 <br> Valid values: 1...250")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="page through results, default: 1")] = None,
        sparkline: Annotated[Optional[StrictBool], Field(description="include sparkline 7 days data, default: false")] = None,
        price_change_percentage: Annotated[Optional[StrictStr], Field(description="include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y")] = None,
        locale: Annotated[Optional[StrictStr], Field(description="language background, default: en")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoinsMarkets:
        """Coins List with Market Data

        This endpoint allows you to **query all the supported coins with price, market cap, volume and market related data**

        :param vs_currency: target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param ids: coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).
        :type ids: str
        :param category: filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).
        :type category: str
        :param order: sort result by field, default: market_cap_desc
        :type order: str
        :param per_page: total results per page, default: 100 <br> Valid values: 1...250
        :type per_page: float
        :param page: page through results, default: 1
        :type page: float
        :param sparkline: include sparkline 7 days data, default: false
        :type sparkline: bool
        :param price_change_percentage: include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y
        :type price_change_percentage: str
        :param locale: language background, default: en
        :type locale: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_markets_serialize(
            vs_currency=vs_currency,
            ids=ids,
            category=category,
            order=order,
            per_page=per_page,
            page=page,
            sparkline=sparkline,
            price_change_percentage=price_change_percentage,
            locale=locale,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarkets",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_markets_with_http_info(
        self,
        vs_currency: Annotated[StrictStr, Field(description="target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        ids: Annotated[Optional[StrictStr], Field(description="coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).")] = None,
        category: Annotated[Optional[StrictStr], Field(description="filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).")] = None,
        order: Annotated[Optional[StrictStr], Field(description="sort result by field, default: market_cap_desc")] = None,
        per_page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="total results per page, default: 100 <br> Valid values: 1...250")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="page through results, default: 1")] = None,
        sparkline: Annotated[Optional[StrictBool], Field(description="include sparkline 7 days data, default: false")] = None,
        price_change_percentage: Annotated[Optional[StrictStr], Field(description="include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y")] = None,
        locale: Annotated[Optional[StrictStr], Field(description="language background, default: en")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoinsMarkets]:
        """Coins List with Market Data

        This endpoint allows you to **query all the supported coins with price, market cap, volume and market related data**

        :param vs_currency: target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param ids: coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).
        :type ids: str
        :param category: filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).
        :type category: str
        :param order: sort result by field, default: market_cap_desc
        :type order: str
        :param per_page: total results per page, default: 100 <br> Valid values: 1...250
        :type per_page: float
        :param page: page through results, default: 1
        :type page: float
        :param sparkline: include sparkline 7 days data, default: false
        :type sparkline: bool
        :param price_change_percentage: include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y
        :type price_change_percentage: str
        :param locale: language background, default: en
        :type locale: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_markets_serialize(
            vs_currency=vs_currency,
            ids=ids,
            category=category,
            order=order,
            per_page=per_page,
            page=page,
            sparkline=sparkline,
            price_change_percentage=price_change_percentage,
            locale=locale,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarkets",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_markets_without_preload_content(
        self,
        vs_currency: Annotated[StrictStr, Field(description="target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        ids: Annotated[Optional[StrictStr], Field(description="coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).")] = None,
        category: Annotated[Optional[StrictStr], Field(description="filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).")] = None,
        order: Annotated[Optional[StrictStr], Field(description="sort result by field, default: market_cap_desc")] = None,
        per_page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="total results per page, default: 100 <br> Valid values: 1...250")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="page through results, default: 1")] = None,
        sparkline: Annotated[Optional[StrictBool], Field(description="include sparkline 7 days data, default: false")] = None,
        price_change_percentage: Annotated[Optional[StrictStr], Field(description="include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y")] = None,
        locale: Annotated[Optional[StrictStr], Field(description="language background, default: en")] = None,
        precision: Annotated[Optional[StrictStr], Field(description="decimal place for currency price value")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Coins List with Market Data

        This endpoint allows you to **query all the supported coins with price, market cap, volume and market related data**

        :param vs_currency: target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param ids: coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).
        :type ids: str
        :param category: filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).
        :type category: str
        :param order: sort result by field, default: market_cap_desc
        :type order: str
        :param per_page: total results per page, default: 100 <br> Valid values: 1...250
        :type per_page: float
        :param page: page through results, default: 1
        :type page: float
        :param sparkline: include sparkline 7 days data, default: false
        :type sparkline: bool
        :param price_change_percentage: include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y
        :type price_change_percentage: str
        :param locale: language background, default: en
        :type locale: str
        :param precision: decimal place for currency price value
        :type precision: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_markets_serialize(
            vs_currency=vs_currency,
            ids=ids,
            category=category,
            order=order,
            per_page=per_page,
            page=page,
            sparkline=sparkline,
            price_change_percentage=price_change_percentage,
            locale=locale,
            precision=precision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoinsMarkets",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_markets_serialize(
        self,
        vs_currency,
        ids,
        category,
        order,
        per_page,
        page,
        sparkline,
        price_change_percentage,
        locale,
        precision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if vs_currency is not None:
            
            _query_params.append(('vs_currency', vs_currency))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if sparkline is not None:
            
            _query_params.append(('sparkline', sparkline))
            
        if price_change_percentage is not None:
            
            _query_params.append(('price_change_percentage', price_change_percentage))
            
        if locale is not None:
            
            _query_params.append(('locale', locale))
            
        if precision is not None:
            
            _query_params.append(('precision', precision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/markets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def coins_top_gainers_losers(
        self,
        vs_currency: Annotated[StrictStr, Field(description="target currency of coins <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        duration: Annotated[Optional[StrictStr], Field(description="filter result by time range <br> Default value: `24h`")] = None,
        top_coins: Annotated[Optional[StrictStr], Field(description="filter result by market cap ranking (top 300 to 1000) or all coins (including coins that do not have market cap) <br> Default value: `1000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[TopGainersLosersInner]:
        """💼 Top Gainers & Losers

        This endpoint allows you to **query the top 30 coins with largest price gain and loss by a specific time duration**

        :param vs_currency: target currency of coins <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param duration: filter result by time range <br> Default value: `24h`
        :type duration: str
        :param top_coins: filter result by market cap ranking (top 300 to 1000) or all coins (including coins that do not have market cap) <br> Default value: `1000`
        :type top_coins: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_top_gainers_losers_serialize(
            vs_currency=vs_currency,
            duration=duration,
            top_coins=top_coins,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[TopGainersLosersInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def coins_top_gainers_losers_with_http_info(
        self,
        vs_currency: Annotated[StrictStr, Field(description="target currency of coins <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        duration: Annotated[Optional[StrictStr], Field(description="filter result by time range <br> Default value: `24h`")] = None,
        top_coins: Annotated[Optional[StrictStr], Field(description="filter result by market cap ranking (top 300 to 1000) or all coins (including coins that do not have market cap) <br> Default value: `1000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[TopGainersLosersInner]]:
        """💼 Top Gainers & Losers

        This endpoint allows you to **query the top 30 coins with largest price gain and loss by a specific time duration**

        :param vs_currency: target currency of coins <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param duration: filter result by time range <br> Default value: `24h`
        :type duration: str
        :param top_coins: filter result by market cap ranking (top 300 to 1000) or all coins (including coins that do not have market cap) <br> Default value: `1000`
        :type top_coins: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_top_gainers_losers_serialize(
            vs_currency=vs_currency,
            duration=duration,
            top_coins=top_coins,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[TopGainersLosersInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def coins_top_gainers_losers_without_preload_content(
        self,
        vs_currency: Annotated[StrictStr, Field(description="target currency of coins <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).")],
        duration: Annotated[Optional[StrictStr], Field(description="filter result by time range <br> Default value: `24h`")] = None,
        top_coins: Annotated[Optional[StrictStr], Field(description="filter result by market cap ranking (top 300 to 1000) or all coins (including coins that do not have market cap) <br> Default value: `1000`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """💼 Top Gainers & Losers

        This endpoint allows you to **query the top 30 coins with largest price gain and loss by a specific time duration**

        :param vs_currency: target currency of coins <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies). (required)
        :type vs_currency: str
        :param duration: filter result by time range <br> Default value: `24h`
        :type duration: str
        :param top_coins: filter result by market cap ranking (top 300 to 1000) or all coins (including coins that do not have market cap) <br> Default value: `1000`
        :type top_coins: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._coins_top_gainers_losers_serialize(
            vs_currency=vs_currency,
            duration=duration,
            top_coins=top_coins,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[TopGainersLosersInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _coins_top_gainers_losers_serialize(
        self,
        vs_currency,
        duration,
        top_coins,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if vs_currency is not None:
            
            _query_params.append(('vs_currency', vs_currency))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if top_coins is not None:
            
            _query_params.append(('top_coins', top_coins))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'proKeyAuth', 
            'demoKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/coins/top_gainers_losers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


